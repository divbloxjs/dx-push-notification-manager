const divbloxPackageControllerBase = require("divbloxjs/dx-core-modules/package-controller-base");
const DivbloxBase = require("divbloxjs/divblox");
const webPush = require("web-push");
const dxQ = require("divbloxjs/dx-orm/query-model-base");

const PushSubscription = require("../../divblox-packages-local/dx-push-notification-manager/push-subscription/push-subscription.model");

/*
This package controller was generated by the divbloxjs package generator.
*/

class DxPushNotifications extends divbloxPackageControllerBase {
    /**
     * A basic constructor that can be overridden
     * @param {DivbloxBase} dxInstance An instance of divbloxjs to allow for access to the app configuration
     * @param {string} packageName The name given to this package
     */
    constructor(dxInstance = null, packageName = "dx-push-notification-manager") {
        super(dxInstance, packageName);

        if (typeof this.packageOptions["vapidKeys"] === "undefined") {
            this.packageOptions["vapidKeys"] = {
                publicKey: "123",
                privateKey: "123",
            };
        }

        if (typeof this.packageOptions["pushEmailAddress"] === "undefined") {
            this.packageOptions["pushEmailAddress"] = "mailto:myuserid@email.com";
        }

        webPush.setVapidDetails(
            this.packageOptions["pushEmailAddress"],
            this.packageOptions["vapidKeys"].publicKey,
            this.packageOptions["vapidKeys"].privateKey,
        );
    }

    /**
     * Hashes the endpoing in the push subscription object for indexing and easier reference
     * @param {*} pushSubscriptionObject A valid push subscription object that contains an endpoint
     * @returns
     */
    async createPushSubscriptionIndex(pushSubscriptionObject) {
        if (typeof pushSubscriptionObject === undefined || typeof pushSubscriptionObject["endpoint"] === undefined) {
            this.populateError("Invalid push subscription object provided.");
            return -1;
        }
        return require("crypto").createHash("md5").update(pushSubscriptionObject.endpoint).digest("hex");
    }

    /**
     * Stores a push subcription in the database
     * @param {{endpoint:string,expirationTime:number,keys:{p256dh:string,auth:string}}} pushSubscriptionObject
     * @param {string} vapidPublicKey The VAPID key to validate that this push subscription is actually ours
     * @param {string} globalIdentifier A unique identifier that most likely will associate to a user
     * @returns {Promise<string|number>} A unique push subscription index if saved, -1 otherwise. Check the last error for more info
     */
    async savePushSubscription(pushSubscriptionObject, vapidPublicKey, globalIdentifier) {
        if (
            pushSubscriptionObject === undefined ||
            pushSubscriptionObject["endpoint"] === undefined ||
            pushSubscriptionObject["keys"] === undefined ||
            pushSubscriptionObject["keys"]["p256dh"] === undefined
        ) {
            this.populateError("Invalid push subscription object provided.");
            return -1;
        }

        if (vapidPublicKey !== this.packageOptions["vapidKeys"].publicKey) {
            this.populateError("Invalid vapid public key provided.");
            return -1;
        }

        const pushSubscriptionIndex = await this.createPushSubscriptionIndex(pushSubscriptionObject);
        if (pushSubscriptionIndex === -1) {
            this.populateError("Invalid push subscription object provided.");
            return -1;
        }

        const pushSubscription = new PushSubscription(this.dxInstance);
        // We try to load it here from the provided push index. If it does not load, we will create it, otherwise we'll just update its data
        await pushSubscription.loadByField("pushSubscriptionIndex", pushSubscriptionIndex);

        pushSubscription.data.pushSubscriptionIndex = pushSubscriptionIndex;
        pushSubscription.data.pushSubscriptionObject = JSON.stringify(pushSubscriptionObject);
        if (globalIdentifier !== undefined) {
            pushSubscription.data.globalIdentifier = globalIdentifier;
        }

        if (!(await pushSubscription.save())) {
            this.populateError(pushSubscription.getLastError());
            return -1;
        }
        return pushSubscriptionIndex;
    }

    /**
     * Deletes the given push subscription from the database
     * @param {{pushSubscriptionObject:{}, pushSubscriptionIndex:string, globalIdentifier:string}} options The various identifiers to load the push subscription from
     * @returns {Promise<boolean>} True if deleted successfully, false otherwise with an error populated
     */
    async deletePushSubscription(options) {
        const pushSubscription = new PushSubscription(this.dxInstance);
        let pushSubscriptionIndex = -1;
        if (options["pushSubscriptionIndex"] !== undefined) {
            // Load via index
            pushSubscriptionIndex = options["pushSubscriptionIndex"];
        } else if (options["pushSubscriptionObject"] !== undefined) {
            // Validate push sub index and load via index
            pushSubscriptionIndex = await this.createPushSubscriptionIndex(options["pushSubscriptionObject"]);
        }

        if (pushSubscriptionIndex === -1) {
            // Load via global id
            if (
                options["globalIdentifier"] !== undefined &&
                !(await pushSubscription.loadByField("globalIdentifier", options["globalIdentifier"]))
            ) {
                this.populateError("Invalid push subscription global identifier provided");
                return false;
            } else if (options["globalIdentifier"] === undefined) {
                this.populateError("Invalid push subscription index provided");
                return false;
            }
        }

        if (
            pushSubscription.data.id < 1 &&
            !(await pushSubscription.loadByField("pushSubscriptionIndex", pushSubscriptionIndex))
        ) {
            this.populateError("Invalid push subscription object provided [2]");
            return false;
        }

        if (!(await pushSubscription.delete())) {
            this.populateError(pushSubscription.getLastError());
            return false;
        }

        return true;
    }

    /**
     * Marks a push subscription as seen
     * @param {{pushSubscriptionIndex:string, globalIdentifier:string}} identifyVia Used to identify the push subscription. Both options are optional, but at least one is required
     * @returns {Promise<boolean>}  True if the push subscription was updated, false otherwise
     */
    async markPushSubscriptionSeen(identifyVia) {
        const pushSubscription = new PushSubscription(this.dxInstance);
        if (identifyVia.pushSubscriptionIndex !== undefined) {
            if (!(await pushSubscription.loadByField("pushSubscriptionIndex", identifyVia.pushSubscriptionIndex))) {
                this.populateError("Invalid push subscription index provided");
                return false;
            }
        } else if (identifyVia.globalIdentifier !== undefined) {
            if (!(await pushSubscription.loadByField("globalIdentifier", identifyVia.globalIdentifier))) {
                this.populateError("Invalid push subscription globalIdentifier provided");
                return false;
            }
        }

        pushSubscription.data.hasUnseenNotification = 0;
        if (!(await pushSubscription.save())) {
            this.populateError(pushSubscription.getLastError());
            return false;
        }

        return true;
    }

    /**
     * Sends a push notification to the given user or device
     * @param {{pushSubscriptionIndex:string, globalIdentifier:string}} identifyVia Used to identify the push subscription. Both options are optional, but at least one is required
     * @param {{notification: {title: string, body: string, image: string, data: {}}}} messageOptions Options as specified by the web push specification
     * @param {boolean} mustSetAsUnseen If set to true, the push subscription will be updated to set the hasUnseenNotification value to true for future use by your app.
     * By default the endpoints provided by this package won't set this flag, so it is intended to be used as needed by your app.
     * @returns {Promise<boolean>}  True if the notification was sent, false otherwise
     */
    async deliverPushNotification(identifyVia, messageOptions, mustSetAsUnseen) {
        const pushSubscription = new PushSubscription(this.dxInstance);
        if (identifyVia.pushSubscriptionIndex !== undefined) {
            if (!(await pushSubscription.loadByField("pushSubscriptionIndex", identifyVia.pushSubscriptionIndex))) {
                this.populateError("Invalid push subscription index provided");
                return false;
            }

            if (mustSetAsUnseen) {
                pushSubscription.data.hasUnseenNotification = 1;
                await pushSubscription.save();
            }
        } else if (identifyVia.globalIdentifier !== undefined) {
            const pushSubscriptionArray = await pushSubscription.findArray(
                { fields: ["pushSubscriptionObject"] },
                dxQ.equal("globalIdentifier", identifyVia.globalIdentifier),
            );

            const errors = [];
            for (const row of pushSubscriptionArray) {
                if (
                    !(await this.sendNotification(
                        JSON.parse(row.pushSubscription.pushSubscriptionObject),
                        messageOptions,
                    ))
                ) {
                    errors.push(this.getLastError());
                }
            }

            if (errors.length !== 0) {
                this.populateError(JSON.stringify(errors));
                return false;
            }
        }

        return true;
    }

    /**
     * This is a bad method. Don't use it. Will query ALL push subscriptions from db and send a message to each one...
     * @param {{notification: {title: string, body: string, image: string, data: {}}}} messageOptions Options as specified by the web push specification
     * @returns {Promise<boolean>}  True if the notification was sent, false otherwise
     */
    async deliverPushNotificationToAll(messageOptions) {
        const pushSubscription = new PushSubscription(this.dxInstance);
        const pushSubscrioptionArray = await pushSubscription.findArray(
            { fields: ["pushSubscriptionObject"] },
            dxQ.all(),
        );
        const errors = [];
        for (const row of pushSubscrioptionArray) {
            if (
                !(await this.sendNotification(JSON.parse(row.pushSubscription.pushSubscriptionObject), messageOptions))
            ) {
                errors.push(this.getLastError());
            }
        }

        if (errors.length !== 0) {
            this.populateError(JSON.stringify(errors));
            return false;
        }

        return true;
    }

    /**
     * Sends a push notification using the given push subscription and options. This is basically a wrapper for web push sendNotification()
     * @param {{endpoint:string, expirationTime:number, keys:{p256dh:string, auth:string}}} pushSubscription The push subcsription object that contains the endpoint and keys
     * @param {{notification: {title: string, body: string, image: string, data: {}}}} options Options as specified by the web push specification
     * @returns {Promise<boolean>}  True if the notification was sent, false otherwise
     */
    async sendNotification(pushSubscription, options) {
        try {
            const result = await webPush.sendNotification(pushSubscription, JSON.stringify(options), {timeout: 5000});
        } catch (error) {
            this.populateError(error);
            return false;
        }
        return true;
    }
}

module.exports = DxPushNotifications;
